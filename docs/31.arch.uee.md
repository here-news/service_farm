# 31 — Universal Epistemic Engine (UEE)

> The core engine for event emergence, growth, and metabolism

---

## Overview

The Universal Epistemic Engine (UEE) is the computational heart of HERE.news. It implements the EVENT protocol through a **single fractal operation** that works at all scales:

```
compute_affinity(A, B) → score ∈ [0, 1]
```

Where A and B can be:
- `(claim, event)` — should this claim join this event?
- `(event, event)` — should these events merge?

**The same rules apply at every level.** This is the "fractal" property that makes the system universal.

---

## 1. The Core Operation: compute_affinity()

### Multi-Signal Scoring

```python
affinity = (
    0.60 × semantic_similarity +    # Embedding cosine similarity
    0.25 × entity_overlap +          # Shared entities (Jaccard or coverage)
    0.15 × entity_specificity        # IDF-weighted rare entity bonus
)
```

### Signal Breakdown

| Signal | Weight | Measure | Rationale |
|--------|--------|---------|-----------|
| **Semantic** | 60% | `cosine(embedding_A, embedding_B)` | Topical relatedness |
| **Entity Overlap** | 25% | `\|A ∩ B\| / \|A\|` or Jaccard | Shared actors/places |
| **Entity Specificity** | 15% | `1 - freq(e) / max_freq` | Rare entities = stronger signal |

### Why These Weights?

- **Semantic is primary** because two claims about the same topic should cluster even if they mention different people
- **Entity overlap is secondary** because the same event often involves different supporting actors across sources
- **Specificity prevents over-merging** — "Hong Kong" appears everywhere, but "Wang Fuk Court" is specific

---

## 2. Data Structures

### Claim

```python
Claim:
    id:           str                 # Unique identifier
    text:         str                 # The assertion
    page_id:      str                 # Source page
    entity_ids:   List[str]           # Entities mentioned
    embedding:    List[float]         # Semantic vector
    timestamp:    Optional[datetime]  # When published
```

### Event

```python
Event:
    id:                  str
    claim_ids:           List[str]         # Claims in this event
    entity_surface:      Set[str]          # All entities from all claims
    embedding_centroid:  List[float]       # Average of claim embeddings

    # Jaynesian quantities
    mass:                float             # Σ source_credibility
    heat:                float             # Σ exp(-λ × hours_since_claim)
    entropy:             float             # -Σ p_i × log(p_i) over contested values
    coherence:           float             # corroborates / (corroborates + contradicts)

    # Metadata
    sources:             Set[str]          # Distinct source domains
    state:               EventState        # LIVE | WARM | DORMANT | ARCHIVED
```

### Source Credibility Priors

```python
SOURCE_CREDIBILITY = {
    'bbc.com':        0.90,
    'reuters.com':    0.88,
    'apnews.com':     0.88,
    'theguardian.com': 0.85,
    'dw.com':         0.85,
    'cnn.com':        0.80,
    'scmp.com':       0.82,
    'aljazeera.com':  0.80,
    'newsweek.com':   0.70,
    'nypost.com':     0.60,
    'default':        0.50
}
```

---

## 3. The Processing Pipeline

### Phase 1: Claim Processing

For each incoming claim:

```
┌─────────────────────────────────────────────────────────────────┐
│  for event in existing_events:                                  │
│      score = compute_affinity(claim, event)                     │
│                                                                 │
│  best_event = argmax(score)                                     │
│                                                                 │
│  if best_score >= THRESHOLD (0.45):                             │
│      JOIN: add claim to best_event                              │
│      - event.claim_ids.append(claim.id)                         │
│      - event.entity_surface.update(claim.entities)              │
│      - event.mass += source_credibility                         │
│      - update event.embedding_centroid (running average)        │
│  else:                                                          │
│      SEED: create new event from claim                          │
└─────────────────────────────────────────────────────────────────┘
```

### Phase 2: Event Merge (Same Rules)

Periodically, apply the same affinity logic to events:

```
┌─────────────────────────────────────────────────────────────────┐
│  for each pair (event_A, event_B):                              │
│      score = compute_affinity(event_A, event_B)                 │
│                                                                 │
│  if score >= MERGE_THRESHOLD (0.50):                            │
│      MERGE: combine B into A                                    │
│      - A.claim_ids.extend(B.claim_ids)                          │
│      - A.entity_surface.update(B.entity_surface)                │
│      - A.mass += B.mass                                         │
│      - update A.embedding_centroid                              │
│      - remove B from events                                     │
└─────────────────────────────────────────────────────────────────┘
```

### Phase 3: Distillation

Each event produces Jaynesian output:

```
┌─────────────────────────────────────────────────────────────────┐
│  DISTILLED EVENT                                                │
│                                                                 │
│  QUANTITATIVE:                                                  │
│    mass:      sum of source credibilities                       │
│    claims:    count                                             │
│    sources:   count of distinct domains                         │
│    entities:  key entities by specificity                       │
│    coherence: corroborates / total_edges                        │
│    entropy:   uncertainty over contested values                 │
│                                                                 │
│  QUALITATIVE:                                                   │
│    what_we_know:   top claims by credibility                    │
│    what_differs:   claims with differing values (UPDATES chain) │
│    evolution:      if timestamps, show progression              │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. Growth Dynamics

As events grow, they become "stickier":

```
Event absorbs claim
       ↓
entity_surface expands → more entities to match future claims
       ↓
mass increases → (optional) mass bonus in scoring
       ↓
centroid stabilizes → better semantic anchor
       ↓
Event becomes attractor basin
```

This creates **positive feedback**: larger events attract more claims.

### The Entity Surface Effect

```
Initial event: 3 claims, 5 entities
       ↓
New claim shares 2 entities → JOINS (entity overlap sufficient)
       ↓
Event now has 4 claims, 7 entities
       ↓
More claims can now match (larger surface area)
```

---

## 5. Edge Types and Relations

The engine recognizes three claim relations:

### CORROBORATES
- High semantic similarity (>0.85)
- Claims assert the same thing
- Strengthens confidence
- Increases coherence

### DIFFERS
- Moderate similarity (0.5-0.85)
- Shared entities
- Same topic, different details
- Resolved at distillation time via timestamps

### INDEPENDENT
- Low similarity (<0.5)
- No shared entities
- Different topics
- Claims don't connect

### Handling DIFFERS (Updates vs Contradictions)

Rather than forcing UPDATE vs CONTRADICT at edge creation, we use DIFFERS and resolve at distillation:

```
IF timestamps available:
    current_state = latest claim
    history = earlier claims
    → EVOLUTION chain

IF no timestamps:
    show range: "Death toll: 36-160 (evolving)"
    OR mark as "uncertain/contested"
```

---

## 6. Display Metrics

### Display Score Formula

```python
display_score = mass × heat_factor × diversity_factor × (1 - entropy_penalty)

Where:
    heat_factor     = min(1.5, 0.5 + heat / max_heat)
    diversity_factor = log(1 + sources)
    entropy_penalty = 0.5 × normalized_entropy
```

### Display Tiers

| Tier | Criteria | Use Case |
|------|----------|----------|
| **HEADLINE** | display > 100, sources ≥ 5 | Homepage feature |
| **SIGNIFICANT** | display > 50, sources ≥ 3 | Category pages |
| **EMERGING** | display > 20, high heat | Watchlist |
| **INTERNAL** | display < 20 | Not yet public |

---

## 7. Claim Pool Architecture

The UEE operates on a **Claim Pool** rather than page-level routing:

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLAIM POOL                               │
│                                                                  │
│  Sources:                                                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│  │ Community │  │ Crawler  │  │ API Feed │  │ Partner  │         │
│  │ (UI)      │  │          │  │          │  │          │         │
│  └─────┬─────┘  └─────┬────┘  └─────┬────┘  └─────┬────┘         │
│        │              │            │             │               │
│        └──────────────┴────────────┴─────────────┘               │
│                           │                                      │
│                           ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                    queue:claims:pending                      │ │
│  │  Each claim has:                                             │ │
│  │  - text, entities, embedding                                 │ │
│  │  - source_url, submitter_id                                  │ │
│  │  - energy_stake (anti-spam)                                  │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                           │                                      │
│                           ▼                                      │
│                     UEE WORKER                                   │
│                  (claim-level routing)                           │
└─────────────────────────────────────────────────────────────────┘
```

### Key Difference from Page Routing

| Aspect | Page Routing | Claim Pool (UEE) |
|--------|--------------|------------------|
| Unit | Page (all claims together) | Individual claim |
| Orphans | ~50% lost | 0% by design |
| Cross-event | No | Yes (one claim → multiple events) |
| Community | Submit URL | Submit claim directly |

---

## 8. Economic Layer

### Energy Stake (Anti-Gaming)

```python
To submit a claim, stake energy:
    stake = BASE_COST × reputation_factor

Where reputation_factor:
    - New user: 1.0
    - Trusted: 0.5 (discount)
    - Suspicious: 2.0+ (penalty)

If claim is LOW QUALITY: stake BURNED
If claim is HIGH QUALITY: stake returned + REWARD
```

### Reward Signals

| Behavior | Reward | Rationale |
|----------|--------|-----------|
| **Corroboration** | stake × factor | Bayesian: P(true\|n) >> P(true\|1) |
| **Entropy Reduction** | stake × Δentropy × credibility | Knowledge = uncertainty reduction |
| **Source Diversity** | stake × novelty | Independent verification |
| **Bridge Claims** | stake × bridge_value | Cross-event meta-narratives |
| **Early Signal** | stake / log(mass) | Breaking news incentive |

### Attack Resistance

| Attack | Defense |
|--------|---------|
| Spam flood | Energy stake + rate limiting |
| Sybil | New accounts = high cost, slow reputation |
| Disinfo | Source credibility weighting |
| Fake corroboration | Same-source claims don't count |
| Entropy manipulation | Only NEW credible sources reduce entropy |

---

## 9. Cross-Event Claims

A key UEE advantage: **one claim can contribute to multiple events**.

### Example

```
CLAIM: "John Lee said the government will not tolerate exploitation of the tragedy"

Contributes to:
├── EVENT: "HK Fire"       (government response)
├── EVENT: "HK Governance" (leadership pattern)
└── ENTITY: "John Lee"     (biographical)
```

### Entity Bridges

Entities that appear in multiple events create **meta-narratives**:

```
Bridge entities found:
    Hong Kong       → fire, lai (HK governance meta-narrative)
    John Lee        → fire, lai (leadership performance)
    Donald Trump    → lai, bondi (international response)
    Keir Starmer    → lai, bondi (UK government response)
```

---

## 10. Validated Results

Testing on 1,271 claims across 120 pages:

### Event Emergence

| Event | Claims | Mass | Sources |
|-------|--------|------|---------|
| HK Fire | 140 | 81.6 | 24 |
| Jimmy Lai | 129 | 77.1 | 26 |
| Bondi Beach | 73 | 48.2 | 8 |
| Brown Shooting | 51 | - | 8 |
| Venezuela | 49 | - | 5 |

### Alignment with Editorial Judgment

The same major events emerge as a human editor would identify:
- Mass casualty events (fire, shooting) → high priority
- Ongoing trials (Lai) → significant coverage
- International incidents (Venezuela) → moderate coverage

**The system captures "newsworthiness" algorithmically.**

---

## 11. Implementation Path

### Phase 1: Claim Pool + UEE Worker
- Replace page-level routing with claim-level
- Implement compute_affinity() as core operation
- Add claim queue with validation

### Phase 2: Jaynesian Quantities
- Add mass, heat, entropy to events
- Implement display_score ranking
- Surface events by tier

### Phase 3: Economic Layer
- Add energy stake mechanism
- Implement reward computation
- Build reputation system

### Phase 4: Community Integration
- UI for claim submission
- Show rewards and reputation
- Feedback loop complete

---

## 12. Key Properties

| Property | Description |
|----------|-------------|
| **Fractal** | Same compute_affinity() at claim→event and event→event |
| **Scalable** | Entity routing reduces O(N²) to O(N × avg_entities) |
| **Incremental** | Claims processed as they arrive |
| **Universal** | No domain-specific patterns; works for any event type |
| **Jaynesian** | Proper uncertainty quantification via entropy |

---

## References

- `docs/23.theory.event-protocol.md` — EVENT protocol specification
- `docs/22.theory.metabolism.md` — Metabolism equations
- `docs/32.arch.event-formation.md` — Event formation details
- `backend/test_eu/unified_engine.py` — Reference implementation
- `backend/test_eu/full_chain_demo.py` — Full pipeline demonstration

---

*The UEE is the computational substrate where events emerge, grow, and resolve. Same rules, all scales.*
